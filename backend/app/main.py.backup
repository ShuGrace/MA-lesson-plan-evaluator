from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from app.db.database import Database, init_database
from typing import List, Optional
from pydantic import BaseModel
import traceback
from contextlib import asynccontextmanager

# Import config and LLMClient
from app.config import API_MODE
from app.services.llm_client import LLMClient

# ==========================================
# Lifespan handler (startup/shutdown)
# ==========================================
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    try:
        init_database(reset=False)
        print("‚úÖ Database initialized successfully")
    except Exception as e:
        print(f"‚ö†Ô∏è  Database initialization warning: {e}")
    yield
    # Shutdown
    print("üëã Application shutdown")

app = FastAPI(title="Lesson Plan Evaluator API", lifespan=lifespan)

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==========================================
# Pydantic Models
# ==========================================
class EvaluationCreate(BaseModel):
    lesson_plan_text: str
    lesson_plan_title: Optional[str] = None
    grade_level: Optional[str] = None
    subject_area: Optional[str] = None

class EvaluationUpdate(BaseModel):
    place_based_score: Optional[int] = None
    cultural_score: Optional[int] = None
    overall_score: Optional[int] = None
    status: Optional[str] = None
    agent_responses: Optional[List[dict]] = None
    debate_transcript: Optional[dict] = None
    recommendations: Optional[List[str]] = None

# ==========================================
# Database Dependency
# ==========================================
def get_db():
    db = Database()
    db.connect()
    try:
        yield db
    finally:
        db.close()

# ==========================================
# Root Endpoint
# ==========================================
@app.get("/")
async def root():
    return {
        "message": "Lesson Plan Evaluator API",
        "mode": API_MODE,
        "database": "connected",
        "status": "operational"
    }

# ==========================================
# CRUD Endpoints
# ==========================================
@app.post("/api/evaluations", response_model=dict)
async def create_evaluation_record(evaluation: EvaluationCreate, db: Database = Depends(get_db)):
    try:
        eval_id = db.create_evaluation(
            lesson_plan_text=evaluation.lesson_plan_text,
            lesson_plan_title=evaluation.lesson_plan_title,
            grade_level=evaluation.grade_level,
            subject_area=evaluation.subject_area,
            api_mode=API_MODE
        )
        return {"status": "success", "evaluation_id": eval_id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create evaluation: {str(e)}")

@app.get("/api/evaluations")
async def get_all_evaluations(limit: int = 50, status: Optional[str] = None, db: Database = Depends(get_db)):
    try:
        if status:
            evals = db.get_evaluations_by_status(status)
        else:
            evals = db.get_all_evaluations(limit=limit)
        return {
            "status": "success",
            "evaluations": evals,
            "count": len(evals)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve evaluations: {str(e)}")

@app.get("/api/evaluations/{evaluation_id}")
async def get_evaluation_by_id(evaluation_id: int, db: Database = Depends(get_db)):
    evaluation = db.get_evaluation(evaluation_id)
    if not evaluation:
        raise HTTPException(status_code=404, detail="Evaluation not found")
    return {
        "status": "success",
        "evaluation": evaluation
    }

@app.put("/api/evaluations/{evaluation_id}", response_model=dict)
async def update_evaluation(evaluation_id: int, update_data: EvaluationUpdate, db: Database = Depends(get_db)):
    evaluation = db.get_evaluation(evaluation_id)
    if not evaluation:
        raise HTTPException(status_code=404, detail="Evaluation not found")

    if all([update_data.place_based_score, update_data.cultural_score, update_data.overall_score]):
        db.update_evaluation_scores(
            eval_id=evaluation_id,
            place_based_score=update_data.place_based_score,
            cultural_score=update_data.cultural_score,
            overall_score=update_data.overall_score
        )

    if update_data.agent_responses or update_data.debate_transcript or update_data.recommendations:
        db.update_evaluation_results(
            eval_id=evaluation_id,
            agent_responses=update_data.agent_responses or [],
            debate_transcript=update_data.debate_transcript or {},
            recommendations=update_data.recommendations or [],
            status=update_data.status or "completed"
        )

    if update_data.status and not any([update_data.agent_responses, update_data.debate_transcript, update_data.recommendations]):
        db.update_evaluation_status(evaluation_id, update_data.status)

    return {"status": "success", "evaluation_id": evaluation_id}

@app.delete("/api/evaluations/{evaluation_id}", response_model=dict)
async def delete_evaluation_record(evaluation_id: int, db: Database = Depends(get_db)):
    evaluation = db.get_evaluation(evaluation_id)
    if not evaluation:
        raise HTTPException(status_code=404, detail="Evaluation not found")
    db.delete_evaluation(evaluation_id)
    return {"status": "success", "message": "Evaluation deleted successfully"}

@app.get("/api/statistics")
async def get_statistics(db: Database = Depends(get_db)):
    try:
        stats = db.get_statistics()
        return {
            "status": "success",
            "statistics": stats
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve statistics: {str(e)}")

# ==========================================
# Evaluation Endpoint (FIXED - Now returns scores!)
# ==========================================
llm_client = LLMClient()

@app.post("/api/evaluate/lesson")
async def evaluate_lesson(lesson_plan: dict, db: Database = Depends(get_db)):
    """
    Main evaluation endpoint - returns scores and agent evaluations
    """
    text = lesson_plan.get("text", "")
    
    print(f"üìù Evaluating lesson plan: {lesson_plan.get('title', 'Untitled')}")

    if API_MODE == "mock":
        # Mock scores with realistic values
        place_based_score = 84
        cultural_score = 82
        critical_pedagogy_score = 76
        assessment_quality_score = 74
        reflective_practice_score = 73
        overall_score = 78
        
        agent_responses = [
            {
                "agent": "DeepSeek", 
                "role": "Place-Based Learning & Pedagogical Design Expert", 
                "model": "deepseek-chat",
                "timestamp": "2024-01-15T10:30:00Z",
                "analysis": {
                    "place_based_learning": {
                        "score": 84,
                        "strengths": [
                            "Strong community engagement through field visits to local awa",
                            "Authentic learning experiences with real environmental data",
                            "Effective integration of local expertise and resources",
                            "Clear connections between classroom learning and community context"
                        ],
                        "areas_for_improvement": [
                            "Could strengthen interdisciplinary connections (science + social studies + arts)",
                            "Recommend adding student-led inquiry components",
                            "Consider long-term community partnership sustainability plan"
                        ]
                    },
                    "pedagogical_design": {
                        "score": 82,
                        "comment": "Solid instructional design with clear learning progression and scaffolding"
                    }
                },
                "recommendations": [
                    "Add explicit interdisciplinary connections mapped to curriculum standards",
                    "Design scaffolded inquiry questions for different ability levels",
                    "Include extension activities for advanced learners",
                    "Create community partnership sustainability plan"
                ]
            },
            {
                "agent": "Claude", 
                "role": "Cultural Responsiveness & Indigenous Education Expert", 
                "model": "claude-sonnet-4-5",
                "timestamp": "2024-01-15T10:30:05Z",
                "analysis": {
                    "cultural_responsiveness": {
                        "score": 82,
                        "strengths": [
                            "Good use of te reo MƒÅori throughout the lesson",
                            "Demonstrates respect for tikanga MƒÅori protocols",
                            "Includes consultation with local kaumƒÅtua",
                            "Shows understanding of kaitiakitanga (guardianship) principles"
                        ],
                        "areas_for_improvement": [
                            "Could deepen understanding of mauri (life force) concept",
                            "Add more explicit cultural safety protocols",
                            "Recommend earlier consultation with mana whenua in planning stage"
                        ],
                        "cultural_elements_present": [
                            "Te reo MƒÅori vocabulary",
                            "Whakapapa (genealogy) connections",
                            "Karakia (prayer/incantation)",
                            "Whanaungatanga (relationships)"
                        ]
                    }
                },
                "recommendations": [
                    "Invite kaitiaki (guardians) to co-teach specific sessions",
                    "Create a cultural protocol checklist for field visits",
                    "Incorporate more whakataukƒ´ (proverbs) relevant to water",
                    "Develop formal relationship with local marae before project begins"
                ],
                "resources_suggested": ["peer_feedback_protocol"]
            },
            {
                "agent": "GPT-4", 
                "role": "Critical Pedagogy, Assessment & Reflective Practice Expert", 
                "model": "gpt-4-turbo",
                "timestamp": "2024-01-15T10:30:10Z",
                "analysis": {
                    "critical_pedagogy": {
                        "score": 76,
                        "strengths": [
                            "Encourages student-led inquiry",
                            "Addresses real community environmental issues",
                            "Promotes student agency in problem-solving"
                        ],
                        "gaps": [
                            "üö© MISSING: Critical analysis of root causes (WHY problems exist)",
                            "üö© MISSING: Power/justice analysis (WHO is affected, WHO decides)",
                            "üö© MISSING: Action-oriented component (students as change agents)",
                            "üö© MISSING: Scaffolding for critical questioning"
                        ]
                    },
                    "assessment_quality": {
                        "score": 74,
                        "strengths": [
                            "Includes authentic audience (community presentation)",
                            "Multiple assessment formats mentioned"
                        ],
                        "gaps": [
                            "üö© CRITICAL: Missing detailed assessment rubric",
                            "üö© MISSING: Clear success criteria",
                            "üö© MISSING: Differentiated assessment options",
                            "üö© MISSING: Self-assessment component"
                        ]
                    },
                    "reflective_practice": {
                        "score": 73,
                        "strengths": [
                            "Includes final reflection component"
                        ],
                        "gaps": [
                            "üö© CRITICAL: No weekly learning journal structure",
                            "üö© MISSING: Ongoing reflection checkpoints throughout project",
                            "üö© MISSING: Peer feedback protocol (Tuakana-Teina model)",
                            "üö© MISSING: Metacognitive reflection prompts"
                        ]
                    }
                },
                "recommendations": [
                    "Add critical thinking scaffolds: 'WHO benefits? WHY is this happening? What historical factors?'",
                    "Develop detailed assessment rubric using provided template",
                    "Implement weekly learning journal with structured prompts (200+ words)",
                    "Establish Tuakana-Teina peer feedback protocol at Weeks 2, 4, 5",
                    "Include student action plan for ongoing community impact"
                ],
                "resources_suggested": ["assessment_rubric", "learning_journal", "peer_feedback_protocol"]
            }
        ]
        
        recommendations = [
            "Strengthen collaboration with kaumƒÅtua and local iwi",
            "Implement detailed assessment rubric with cultural criteria",
            "Add structured learning journal with weekly reflections", 
            "Establish Tuakana-Teina peer feedback protocol",
            "Include critical thinking scaffolds (WHO, WHY, WHAT analysis)"
        ]
        
    else:
        # Real API calls
        print("ü§ñ Calling real LLM APIs...")
        ds_content = await llm_client.call("deepseek", f"Evaluate place-based learning in: {text}")
        cl_content = await llm_client.call("claude", f"Evaluate cultural responsiveness in: {text}")
        cg_content = await llm_client.call("chatgpt", f"Provide overall evaluation and recommendations for: {text}")

        # TODO: Parse actual scores from LLM responses
        place_based_score = 85
        cultural_score = 80
        critical_pedagogy_score = 76
        assessment_quality_score = 74
        reflective_practice_score = 73
        overall_score = 82

        agent_responses = [
            {"agent": "DeepSeek", "role": "Place-Based Learning Expert", "content": ds_content, "score": place_based_score},
            {"agent": "Claude", "role": "Cultural Responsiveness Specialist", "content": cl_content, "score": cultural_score},
            {"agent": "GPT-4", "role": "Critical Pedagogy Facilitator", "content": cg_content, "score": critical_pedagogy_score}
        ]
        
        recommendations = [
            "Strengthen community partnerships", 
            "Increase te reo MƒÅori integration",
            "Add structured reflection components"
        ]

    # Create evaluation in database
    eval_id = db.create_evaluation(
        lesson_plan_text=text,
        lesson_plan_title=lesson_plan.get("title", "Untitled Lesson Plan"),
        grade_level=lesson_plan.get("grade_level", ""),
        subject_area=lesson_plan.get("subject_area", ""),
        api_mode=API_MODE
    )

    # Update with scores
    db.update_evaluation_scores(
        eval_id=eval_id,
        place_based_score=place_based_score,
        cultural_score=cultural_score,
        overall_score=overall_score
    )

    # Update with results
    db.update_evaluation_results(
        eval_id=eval_id,
        agent_responses=agent_responses, 
        debate_transcript={}, 
        recommendations=recommendations, 
        status="completed"
    )

    print(f"‚úÖ Evaluation completed: ID {eval_id}, Overall Score: {overall_score}")

    # Return complete response with ALL scores
    return {
        "status": "success",
        "evaluation_id": eval_id,
        "scores": {
            "place_based_learning": place_based_score,
            "cultural_responsiveness": cultural_score,
            "critical_pedagogy": critical_pedagogy_score,
            "assessment_quality": assessment_quality_score,
            "reflective_practice": reflective_practice_score,
            "overall": overall_score
        },
        "agent_responses": agent_responses,
        "recommendations": recommendations,
        "mode": API_MODE
    }