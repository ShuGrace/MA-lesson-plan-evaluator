from fastapi import FastAPI, Depends, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from app.db.database import Database, init_database
from typing import List, Optional
from pydantic import BaseModel
import traceback
from contextlib import asynccontextmanager
from io import BytesIO
import re

# æ–‡ä»¶å¤„ç†åº“
try:
    import docx
    DOCX_AVAILABLE = True
except ImportError:
    DOCX_AVAILABLE = False
    print("âš ï¸  python-docx not installed. Word file support disabled.")

try:
    import PyPDF2
    PDF_AVAILABLE = True
except ImportError:
    PDF_AVAILABLE = False
    print("âš ï¸  PyPDF2 not installed. PDF file support disabled.")

# Import config and LLMClient
from app.config import API_MODE
from app.services.llm_client import LLMClient

# ==========================================
# Lifespan handler (startup/shutdown)
# ==========================================
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    try:
        init_database(reset=False)
        print("âœ… Database initialized successfully")
    except Exception as e:
        print(f"âš ï¸  Database initialization warning: {e}")
    yield
    # Shutdown
    print("ğŸ‘‹ Application shutdown")

app = FastAPI(title="Lesson Plan Evaluator API", lifespan=lifespan)

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==========================================
# Pydantic Models
# ==========================================
class EvaluationCreate(BaseModel):
    lesson_plan_text: str
    lesson_plan_title: Optional[str] = None
    grade_level: Optional[str] = None
    subject_area: Optional[str] = None

class EvaluationUpdate(BaseModel):
    place_based_score: Optional[int] = None
    cultural_score: Optional[int] = None
    overall_score: Optional[int] = None
    status: Optional[str] = None
    agent_responses: Optional[List[dict]] = None
    debate_transcript: Optional[dict] = None
    recommendations: Optional[List[str]] = None

class ImproveLessonRequest(BaseModel):
    original_lesson: str
    lesson_title: str
    grade_level: Optional[str] = None
    subject_area: Optional[str] = None
    recommendations: List[str]
    scores: dict

# ==========================================
# Database Dependency
# ==========================================
def get_db():
    db = Database()
    db.connect()
    try:
        yield db
    finally:
        db.close()

# ==========================================
# Root Endpoint
# ==========================================
@app.get("/")
async def root():
    return {
        "message": "Lesson Plan Evaluator API",
        "mode": API_MODE,
        "database": "connected",
        "status": "operational",
        "features": {
            "file_upload": {
                "word": DOCX_AVAILABLE,
                "pdf": PDF_AVAILABLE
            }
        }
    }

# ==========================================
# æ–°åŠŸèƒ½1: æ–‡ä»¶æ–‡æœ¬æå–ç«¯ç‚¹
# ==========================================
@app.post("/api/extract-text")
async def extract_text_from_file(file: UploadFile = File(...)):
    """
    ä»ä¸Šä¼ çš„ Word æˆ– PDF æ–‡ä»¶ä¸­æå–æ–‡æœ¬
    """
    try:
        content = await file.read()
        text = ""
        title = ""
        
        if file.filename.endswith('.docx'):
            if not DOCX_AVAILABLE:
                raise HTTPException(status_code=501, detail="Word file support not installed. Please install python-docx: pip install python-docx")
            
            # å¤„ç† Word æ–‡ä»¶
            doc = docx.Document(BytesIO(content))
            paragraphs = [p.text for p in doc.paragraphs if p.text.strip()]
            text = '\n\n'.join(paragraphs)
            
            # æå–æ ‡é¢˜ï¼ˆç¬¬ä¸€ä¸ªéç©ºæ®µè½ï¼‰
            if paragraphs:
                title = paragraphs[0][:100]  # é™åˆ¶æ ‡é¢˜é•¿åº¦
            
        elif file.filename.endswith('.pdf'):
            if not PDF_AVAILABLE:
                raise HTTPException(status_code=501, detail="PDF file support not installed. Please install PyPDF2: pip install PyPDF2")
            
            # å¤„ç† PDF æ–‡ä»¶
            pdf_reader = PyPDF2.PdfReader(BytesIO(content))
            pages_text = []
            for page in pdf_reader.pages:
                page_text = page.extract_text()
                if page_text:
                    pages_text.append(page_text)
            text = '\n\n'.join(pages_text)
            
            # æå–æ ‡é¢˜ï¼ˆæ–‡ä»¶åæˆ–ç¬¬ä¸€è¡Œï¼‰
            title = file.filename.replace('.pdf', '')
            if text:
                first_line = text.split('\n')[0][:100]
                if first_line:
                    title = first_line
            
        elif file.filename.endswith('.doc'):
            # æ—§ç‰ˆWordæ ¼å¼ä¸æ”¯æŒ
            raise HTTPException(status_code=400, detail="æ—§ç‰ˆ .doc æ ¼å¼ä¸æ”¯æŒï¼Œè¯·è½¬æ¢ä¸º .docx æ ¼å¼")
        else:
            raise HTTPException(status_code=400, detail="ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œåªæ”¯æŒ .docx å’Œ .pdf")
        
        if not text.strip():
            raise HTTPException(status_code=400, detail="æ— æ³•ä»æ–‡ä»¶ä¸­æå–æ–‡æœ¬å†…å®¹")
        
        return {
            "status": "success",
            "text": text,
            "metadata": {
                "title": title,
                "filename": file.filename,
                "length": len(text),
                "word_count": len(text.split())
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error extracting text: {str(e)}")
        raise HTTPException(status_code=500, detail=f"æ–‡ä»¶å¤„ç†å¤±è´¥: {str(e)}")

# ==========================================
# æ–°åŠŸèƒ½2: AIæ”¹è¿›æ•™æ¡ˆç”Ÿæˆç«¯ç‚¹
# ==========================================
llm_client = LLMClient()

@app.post("/api/improve-lesson")
async def improve_lesson(request: ImproveLessonRequest):
    """
    æ ¹æ®è¯„ä¼°å»ºè®®ç”Ÿæˆæ”¹è¿›ç‰ˆæ•™æ¡ˆ
    """
    try:
        # æ¸…ç†å»ºè®®åˆ—è¡¨ï¼Œç§»é™¤emojiå’Œé‡å¤é¡¹
        cleaned_recommendations = []
        for rec in request.recommendations:
            # ç§»é™¤emojiå’Œç‰¹æ®Šå­—ç¬¦
            cleaned = re.sub(r'[âš ï¸ğŸš©]', '', rec).strip()
            if cleaned and cleaned not in cleaned_recommendations:
                cleaned_recommendations.append(cleaned)
        
        # æ„å»ºè¯¦ç»†çš„è¯„åˆ†ä¿¡æ¯
        scores_text = f"""
è¯„ä¼°åˆ†æ•°ï¼š
- æ€»åˆ† (Overall): {request.scores.get('overall', 0)}/100
- åœ°æ–¹æ€§å­¦ä¹  (Place-Based Learning): {request.scores.get('place_based_learning', 0)}/100
- æ–‡åŒ–å›åº”æ€§ (Cultural Responsiveness): {request.scores.get('cultural_responsiveness', 0)}/100
- æ‰¹åˆ¤æ€§æ•™å­¦æ³• (Critical Pedagogy): {request.scores.get('critical_pedagogy', 0)}/100
- è¯„ä¼°è´¨é‡ (Assessment Quality): {request.scores.get('assessment_quality', 0)}/100
- åæ€æ€§å®è·µ (Reflective Practice): {request.scores.get('reflective_practice', 0)}/100
"""
        
        # æ„å»ºæç¤ºè¯
        prompt = f"""ä½ æ˜¯ä¸€ä½èµ„æ·±çš„æ–°è¥¿å…°æ•™è‚²ä¸“å®¶ï¼Œä¸“ç²¾äºè¯¾ç¨‹è®¾è®¡å’Œæ•™å­¦æ³•æ”¹è¿›ã€‚è¯·æ ¹æ®ä¸‹é¢çš„è¯„ä¼°ç»“æœå’Œæ”¹è¿›å»ºè®®ï¼Œç”Ÿæˆä¸€ä»½ä¼˜åŒ–åçš„å®Œæ•´æ•™æ¡ˆã€‚

ã€åŸæ•™æ¡ˆä¿¡æ¯ã€‘
æ ‡é¢˜ï¼š{request.lesson_title}
å¹´çº§ï¼š{request.grade_level or 'æœªæŒ‡å®š'}
å­¦ç§‘ï¼š{request.subject_area or 'æœªæŒ‡å®š'}

ã€åŸæ•™æ¡ˆå†…å®¹ã€‘
{request.original_lesson}

ã€è¯„ä¼°ç»“æœã€‘
{scores_text}

ã€æ”¹è¿›å»ºè®®ã€‘ï¼ˆå…± {len(cleaned_recommendations)} æ¡ï¼‰
{chr(10).join(f"{i+1}. {rec}" for i, rec in enumerate(cleaned_recommendations))}

ã€ä»»åŠ¡è¦æ±‚ã€‘
è¯·ç”Ÿæˆä¸€ä»½æ”¹è¿›åçš„å®Œæ•´æ•™æ¡ˆï¼Œè¦æ±‚ï¼š

1. **ä¿ç•™æ ¸å¿ƒä¼˜åŠ¿**ï¼šä¿æŒåŸæ•™æ¡ˆä¸­å¾—åˆ†é«˜çš„éƒ¨åˆ†ï¼ˆå¦‚åœ°æ–¹æ€§å­¦ä¹ ã€æ–‡åŒ–å›åº”æ€§ç­‰ä¼˜åŠ¿ï¼‰
2. **é’ˆå¯¹æ€§æ”¹è¿›**ï¼šé‡ç‚¹ä¼˜åŒ–å¾—åˆ†è¾ƒä½çš„ç»´åº¦ï¼ˆå¦‚æ‰¹åˆ¤æ€§æ•™å­¦æ³•ã€è¯„ä¼°è´¨é‡ã€åæ€æ€§å®è·µï¼‰
3. **æ•´åˆæ‰€æœ‰å»ºè®®**ï¼šç³»ç»Ÿæ€§åœ°èå…¥ä¸Šè¿°æ‰€æœ‰æ”¹è¿›å»ºè®®
4. **æ–°è¥¿å…°æ•™è‚²èƒŒæ™¯**ï¼š
   - ä½“ç° Te WhÄriki å’Œ New Zealand Curriculum çš„ç†å¿µ
   - èå…¥ MÄori æ–‡åŒ–å…ƒç´ å’Œ te reo MÄori
   - æ³¨é‡ whanaungatangaï¼ˆå…³ç³»ï¼‰å’Œ manaakitangaï¼ˆå…³æ€€ï¼‰
5. **å®Œæ•´ç»“æ„**ï¼šåŒ…æ‹¬ä»¥ä¸‹éƒ¨åˆ†
   - è¯¾ç¨‹æ¦‚è¿°ä¸å­¦ä¹ ç›®æ ‡
   - è¯¦ç»†æ•™å­¦æ´»åŠ¨è®¾è®¡ï¼ˆåŒ…å«æ—¶é—´å®‰æ’ï¼‰
   - å·®å¼‚åŒ–æ•™å­¦ç­–ç•¥
   - è¯„ä¼°æ–¹æ³•ä¸æ ‡å‡†ï¼ˆå«è¯¦ç»†è¯„åˆ†æ ‡å‡†ï¼‰
   - åæ€ä¸æ”¹è¿›æœºåˆ¶
   - æ‰€éœ€èµ„æºæ¸…å•

ã€è¾“å‡ºæ ¼å¼ã€‘
è¯·ä½¿ç”¨æ¸…æ™°çš„æ ‡é¢˜å±‚æ¬¡ç»“æ„ï¼Œä½¿ç”¨ Markdown æ ¼å¼è¾“å‡ºå®Œæ•´æ•™æ¡ˆã€‚ç¡®ä¿æ•™æ¡ˆå…·æœ‰å¯æ“ä½œæ€§ï¼Œæ•™å¸ˆå¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚

å¼€å§‹ç”Ÿæˆæ”¹è¿›ç‰ˆæ•™æ¡ˆï¼š
"""
        
        # è°ƒç”¨ Claude API ç”Ÿæˆæ”¹è¿›ç‰ˆæ•™æ¡ˆ
        if API_MODE == "mock":
            # Mock æ¨¡å¼è¿”å›ç¤ºä¾‹
            improved_lesson = f"""# {request.lesson_title} - æ”¹è¿›ç‰ˆ

## è¯¾ç¨‹æ¦‚è¿°
æœ¬è¯¾ç¨‹å·²æ ¹æ®ä¸“å®¶è¯„ä¼°å»ºè®®è¿›è¡Œå…¨é¢ä¼˜åŒ–ï¼Œæå‡äº†æ‰¹åˆ¤æ€§æ€ç»´ã€è¯„ä¼°è´¨é‡å’Œåæ€å®è·µç­‰å…³é”®ç»´åº¦ã€‚

### å­¦ä¹ ç›®æ ‡
1. å­¦ç”Ÿèƒ½å¤Ÿæ‰¹åˆ¤æ€§åœ°åˆ†æç¯å¢ƒé—®é¢˜çš„æ ¹æœ¬åŸå› 
2. å­¦ç”Ÿèƒ½å¤Ÿè¯†åˆ«é—®é¢˜ä¸­çš„æƒåŠ›å’Œæ­£ä¹‰ç»´åº¦
3. å­¦ç”Ÿèƒ½å¤Ÿæå‡ºå¯æŒç»­çš„è§£å†³æ–¹æ¡ˆ

## è¯¦ç»†æ•™å­¦æ´»åŠ¨

### ç¬¬1-2å‘¨ï¼šé—®é¢˜æ¢ç©¶ä¸æ‰¹åˆ¤æ€§åˆ†æ
**æ´»åŠ¨1ï¼šæ‰¹åˆ¤æ€§æé—®æ¡†æ¶** (90åˆ†é’Ÿ)
- å¼•å¯¼å­¦ç”Ÿä½¿ç”¨"WHO, WHY, WHAT"æ¡†æ¶åˆ†æç¤¾åŒºç¯å¢ƒé—®é¢˜
- WHO: è°å—åˆ°å½±å“ï¼Ÿè°åšå‡ºå†³å®šï¼Ÿ
- WHY: ä¸ºä»€ä¹ˆå­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Ÿå†å²æ ¹æºæ˜¯ä»€ä¹ˆï¼Ÿ
- WHAT: å¯ä»¥é‡‡å–ä»€ä¹ˆè¡ŒåŠ¨ï¼Ÿ

### è¯„ä¼°æ–¹æ³•
**è¯¦ç»†è¯„åˆ†æ ‡å‡†ï¼š**
- æ‰¹åˆ¤æ€§åˆ†æ (30%): èƒ½å¤Ÿè¯†åˆ«é—®é¢˜çš„æ ¹æœ¬åŸå› å’ŒæƒåŠ›ç»“æ„
- åä½œèƒ½åŠ› (25%): å›¢é˜Ÿåˆä½œå’Œæ²Ÿé€š
- æ–‡åŒ–å›åº” (20%): ä½“ç° tikanga MÄori å’Œæœ¬åœ°æ–‡åŒ–
- è¡ŒåŠ¨æ–¹æ¡ˆ (25%): æå‡ºå¯è¡Œçš„æ”¹è¿›ç­–ç•¥

### åæ€æœºåˆ¶
**æ¯å‘¨å­¦ä¹ æ—¥å¿—ï¼š**
å­¦ç”Ÿæ¯å‘¨æ’°å†™200å­—çš„åæ€ï¼ŒåŒ…æ‹¬ï¼š
- æœ¬å‘¨å­¦åˆ°äº†ä»€ä¹ˆï¼Ÿ
- é‡åˆ°ä»€ä¹ˆæŒ‘æˆ˜ï¼Ÿ
- ä¸‹ä¸€æ­¥è®¡åˆ’æ˜¯ä»€ä¹ˆï¼Ÿ

**Tuakana-Teina åŒä¼´åé¦ˆï¼š**
åœ¨ç¬¬2ã€4ã€5å‘¨è¿›è¡Œç»“æ„åŒ–çš„åŒä¼´è¯„è®®ã€‚

## èµ„æºæ¸…å•
- æ‰¹åˆ¤æ€§æ€ç»´æ¡†æ¶æ¨¡æ¿
- è¯„ä¼°æ ‡å‡†æ¸…å•
- å­¦ä¹ æ—¥å¿—æ¨¡æ¿
- ç¤¾åŒºè”ç³»äººåå•

ï¼ˆè¿™æ˜¯mockæ¨¡å¼çš„ç¤ºä¾‹å“åº”ï¼‰
"""
        else:
            # å®é™…è°ƒç”¨ Claude API
            improved_lesson = await llm_client.call("claude", prompt)
        
        return {
            "status": "success",
            "improved_lesson": improved_lesson,
            "original_title": request.lesson_title,
            "recommendations_applied": len(cleaned_recommendations)
        }
        
    except Exception as e:
        print(f"Error generating improved lesson: {str(e)}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"ç”Ÿæˆæ”¹è¿›ç‰ˆæ•™æ¡ˆå¤±è´¥: {str(e)}")

# ==========================================
# CRUD Endpoints (ä¿æŒåŸæœ‰åŠŸèƒ½)
# ==========================================
@app.post("/api/evaluations", response_model=dict)
async def create_evaluation_record(evaluation: EvaluationCreate, db: Database = Depends(get_db)):
    try:
        eval_id = db.create_evaluation(
            lesson_plan_text=evaluation.lesson_plan_text,
            lesson_plan_title=evaluation.lesson_plan_title,
            grade_level=evaluation.grade_level,
            subject_area=evaluation.subject_area,
            api_mode=API_MODE
        )
        return {"status": "success", "evaluation_id": eval_id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create evaluation: {str(e)}")

@app.get("/api/evaluations")
async def get_all_evaluations(limit: int = 50, status: Optional[str] = None, db: Database = Depends(get_db)):
    try:
        if status:
            evals = db.get_evaluations_by_status(status)
        else:
            evals = db.get_all_evaluations(limit=limit)
        return {
            "status": "success",
            "evaluations": evals,
            "count": len(evals)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve evaluations: {str(e)}")

@app.get("/api/evaluations/{evaluation_id}")
async def get_evaluation_by_id(evaluation_id: int, db: Database = Depends(get_db)):
    evaluation = db.get_evaluation(evaluation_id)
    if not evaluation:
        raise HTTPException(status_code=404, detail="Evaluation not found")
    return {
        "status": "success",
        "evaluation": evaluation
    }

@app.put("/api/evaluations/{evaluation_id}", response_model=dict)
async def update_evaluation(evaluation_id: int, update_data: EvaluationUpdate, db: Database = Depends(get_db)):
    evaluation = db.get_evaluation(evaluation_id)
    if not evaluation:
        raise HTTPException(status_code=404, detail="Evaluation not found")

    if all([update_data.place_based_score, update_data.cultural_score, update_data.overall_score]):
        db.update_evaluation_scores(
            eval_id=evaluation_id,
            place_based_score=update_data.place_based_score,
            cultural_score=update_data.cultural_score,
            overall_score=update_data.overall_score
        )

    if update_data.agent_responses or update_data.debate_transcript or update_data.recommendations:
        db.update_evaluation_results(
            eval_id=evaluation_id,
            agent_responses=update_data.agent_responses or [],
            debate_transcript=update_data.debate_transcript or {},
            recommendations=update_data.recommendations or [],
            status=update_data.status or "completed"
        )

    if update_data.status and not any([update_data.agent_responses, update_data.debate_transcript, update_data.recommendations]):
        db.update_evaluation_status(evaluation_id, update_data.status)

    return {"status": "success", "evaluation_id": evaluation_id}

@app.delete("/api/evaluations/{evaluation_id}", response_model=dict)
async def delete_evaluation_record(evaluation_id: int, db: Database = Depends(get_db)):
    evaluation = db.get_evaluation(evaluation_id)
    if not evaluation:
        raise HTTPException(status_code=404, detail="Evaluation not found")
    db.delete_evaluation(evaluation_id)
    return {"status": "success", "message": "Evaluation deleted successfully"}

@app.get("/api/statistics")
async def get_statistics(db: Database = Depends(get_db)):
    try:
        stats = db.get_statistics()
        return {
            "status": "success",
            "statistics": stats
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve statistics: {str(e)}")

# ==========================================
# Evaluation Endpoint (ä¿æŒåŸæœ‰åŠŸèƒ½)
# ==========================================
@app.post("/api/evaluate/lesson")
async def evaluate_lesson(lesson_plan: dict, db: Database = Depends(get_db)):
    """
    Main evaluation endpoint - returns scores and agent evaluations
    """
    text = lesson_plan.get("text", "")
    
    print(f"ğŸ“ Evaluating lesson plan: {lesson_plan.get('title', 'Untitled')}")

    if API_MODE == "mock":
        # Mock scores with realistic values
        place_based_score = 84
        cultural_score = 82
        critical_pedagogy_score = 76
        assessment_quality_score = 74
        reflective_practice_score = 73
        overall_score = 82

        agent_responses = [
            {
                "agent": "DeepSeek", 
                "role": "Place-Based Learning & Pedagogical Design Expert", 
                "model": "deepseek-chat",
                "timestamp": "2024-01-15T10:30:00Z",
                "analysis": {
                    "place_based_learning": {
                        "score": 84,
                        "strengths": [
                            "Strong integration of local waterways as learning context",
                            "Meaningful connections to Awa Tupua (river rights) legislation",
                            "Authentic community partnerships with local kaumÄtua and iwi"
                        ],
                        "areas_for_improvement": [
                            "Could expand on historical land use patterns",
                            "Limited connection to students' own neighborhoods",
                            "Recommend adding student-led inquiry components",
                            "Consider long-term community partnership sustainability plan"
                        ]
                    },
                    "pedagogical_design": {
                        "score": 82,
                        "comment": "Solid instructional design with clear learning progression and scaffolding"
                    }
                },
                "recommendations": [
                    "Add explicit interdisciplinary connections mapped to curriculum standards",
                    "Design scaffolded inquiry questions for different ability levels",
                    "Include extension activities for advanced learners",
                    "Create community partnership sustainability plan"
                ]
            },
            {
                "agent": "Claude", 
                "role": "Cultural Responsiveness & Indigenous Education Expert", 
                "model": "claude-sonnet-4-5",
                "timestamp": "2024-01-15T10:30:05Z",
                "analysis": {
                    "cultural_responsiveness": {
                        "score": 82,
                        "strengths": [
                            "Good use of te reo MÄori throughout the lesson",
                            "Demonstrates respect for tikanga MÄori protocols",
                            "Includes consultation with local kaumÄtua",
                            "Shows understanding of kaitiakitanga (guardianship) principles"
                        ],
                        "areas_for_improvement": [
                            "Could deepen understanding of mauri (life force) concept",
                            "Add more explicit cultural safety protocols",
                            "Recommend earlier consultation with mana whenua in planning stage"
                        ],
                        "cultural_elements_present": [
                            "Te reo MÄori vocabulary",
                            "Whakapapa (genealogy) connections",
                            "Karakia (prayer/incantation)",
                            "Whanaungatanga (relationships)"
                        ]
                    }
                },
                "recommendations": [
                    "Invite kaitiaki (guardians) to co-teach specific sessions",
                    "Create a cultural protocol checklist for field visits",
                    "Incorporate more whakataukÄ« (proverbs) relevant to water",
                    "Develop formal relationship with local marae before project begins"
                ],
                "resources_suggested": ["peer_feedback_protocol"]
            },
            {
                "agent": "GPT-4", 
                "role": "Critical Pedagogy, Assessment & Reflective Practice Expert", 
                "model": "gpt-4-turbo",
                "timestamp": "2024-01-15T10:30:10Z",
                "analysis": {
                    "critical_pedagogy": {
                        "score": 76,
                        "strengths": [
                            "Encourages student-led inquiry",
                            "Addresses real community environmental issues",
                            "Promotes student agency in problem-solving"
                        ],
                        "gaps": [
                            "MISSING: Critical analysis of root causes (WHY problems exist)",
                            "MISSING: Power/justice analysis (WHO is affected, WHO decides)",
                            "MISSING: Action-oriented component (students as change agents)",
                            "MISSING: Scaffolding for critical questioning"
                        ]
                    },
                    "assessment_quality": {
                        "score": 74,
                        "strengths": [
                            "Includes authentic audience (community presentation)",
                            "Multiple assessment formats mentioned"
                        ],
                        "gaps": [
                            "CRITICAL: Missing detailed assessment rubric",
                            "MISSING: Clear success criteria",
                            "MISSING: Differentiated assessment options",
                            "MISSING: Self-assessment component"
                        ]
                    },
                    "reflective_practice": {
                        "score": 73,
                        "strengths": [
                            "Includes final reflection component"
                        ],
                        "gaps": [
                            "CRITICAL: No weekly learning journal structure",
                            "MISSING: Ongoing reflection checkpoints throughout project",
                            "MISSING: Peer feedback protocol (Tuakana-Teina model)",
                            "MISSING: Metacognitive reflection prompts"
                        ]
                    }
                },
                "recommendations": [
                    "Add critical thinking scaffolds: 'WHO benefits? WHY is this happening? What historical factors?'",
                    "Develop detailed assessment rubric using provided template",
                    "Implement weekly learning journal with structured prompts (200+ words)",
                    "Establish Tuakana-Teina peer feedback protocol at Weeks 2, 4, 5",
                    "Include student action plan for ongoing community impact"
                ],
                "resources_suggested": ["assessment_rubric", "learning_journal", "peer_feedback_protocol"]
            }
        ]
        
        recommendations = [
            "Strengthen collaboration with kaumÄtua and local iwi",
            "Implement detailed assessment rubric with cultural criteria",
            "Add structured learning journal with weekly reflections", 
            "Establish Tuakana-Teina peer feedback protocol",
            "Include critical thinking scaffolds (WHO, WHY, WHAT analysis)"
        ]
        
    else:
        # Real API calls
        print("ğŸ¤– Calling real LLM APIs...")
        ds_content = await llm_client.call("deepseek", f"Evaluate place-based learning in: {text}")
        cl_content = await llm_client.call("claude", f"Evaluate cultural responsiveness in: {text}")
        cg_content = await llm_client.call("chatgpt", f"Provide overall evaluation and recommendations for: {text}")

        # TODO: Parse actual scores from LLM responses
        place_based_score = 85
        cultural_score = 80
        critical_pedagogy_score = 76
        assessment_quality_score = 74
        reflective_practice_score = 73
        overall_score = 82

        agent_responses = [
            {"agent": "DeepSeek", "role": "Place-Based Learning Expert", "content": ds_content, "score": place_based_score},
            {"agent": "Claude", "role": "Cultural Responsiveness Specialist", "content": cl_content, "score": cultural_score},
            {"agent": "GPT-4", "role": "Critical Pedagogy Facilitator", "content": cg_content, "score": critical_pedagogy_score}
        ]
        
        recommendations = [
            "Strengthen community partnerships", 
            "Increase te reo MÄori integration",
            "Add structured reflection components"
        ]

    # Create evaluation in database
    eval_id = db.create_evaluation(
        lesson_plan_text=text,
        lesson_plan_title=lesson_plan.get("title", "Untitled Lesson Plan"),
        grade_level=lesson_plan.get("grade_level", ""),
        subject_area=lesson_plan.get("subject_area", ""),
        api_mode=API_MODE
    )

    # Update with scores
    db.update_evaluation_scores(
        eval_id=eval_id,
        place_based_score=place_based_score,
        cultural_score=cultural_score,
        overall_score=overall_score
    )

    # Update with results
    db.update_evaluation_results(
        eval_id=eval_id,
        agent_responses=agent_responses, 
        debate_transcript={}, 
        recommendations=recommendations, 
        status="completed"
    )

    print(f"âœ… Evaluation completed: ID {eval_id}, Overall Score: {overall_score}")

    # Return complete response with ALL scores
    return {
        "status": "success",
        "evaluation_id": eval_id,
        "scores": {
            "place_based_learning": place_based_score,
            "cultural_responsiveness": cultural_score,
            "critical_pedagogy": critical_pedagogy_score,
            "assessment_quality": assessment_quality_score,
            "reflective_practice": reflective_practice_score,
            "overall": overall_score
        },
        "agent_responses": agent_responses,
        "recommendations": recommendations,
        "mode": API_MODE
    }